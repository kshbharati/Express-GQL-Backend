import { User } from "@prisma/client";
import { AppContext } from "./context";
import { decodeToken, formatTokenFromRedis } from "./TokenMgmt";
import APIResponse from "./APIResponse";


//TODO Expand return statements to included an APIResponse field with particular error. One way of implementation can be to return a status and message to resolver and resolver checking if the received type is User and returning Error APIResponse if the return type is API Response;

export async function getLoggedUser(ctx: AppContext): Promise<User | APIResponse | undefined | null> {
    
    //Check if token is present.
    if (!ctx.token) return;

    //Get values from token. Values in the token are provided by resolver and generated by generateToken() on ToktnMgmt.ts
    const decodedToken:User= await decodeToken(ctx.token) as User;

    //Check if the token is valid. Invalidity can be caused either due to malformed error or Expired Token 
    if (!decodedToken) return;

    //Get Token saved in Redis
    let dbSavedToken = await ctx.redis.get(decodedToken.email);

    //Check if a token for the userId is present in redis
    if (!dbSavedToken) return;

    //Removes the timestamp prefix
    dbSavedToken=formatTokenFromRedis(dbSavedToken);

    //Check if the token from redis and user provided are same. (Don't need to recheck validity of db token)
    if(dbSavedToken===ctx.token) 
    {

        return;
    }


    // //Checks if the User already has a valid token
    // if(decodedToken.email===email) return;


    //Get User from database
    const user = ctx.prisma.user.findUnique({
        where: {
            id: decodedToken.id,
        },
    });

    if (!user) return;

    return user;
}
