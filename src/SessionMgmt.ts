import { User } from "@prisma/client";
import { AppContext } from "./context";
import { decodeToken, formatTokenFromRedis } from "./TokenMgmt";
import {GQLError, ServerError } from "@root/ErrorHelpers";
import { GraphQLError } from "graphql";


//TODO Return GQLError describing error item instead of returning null.
export async function getLoggedUser(ctx: AppContext): Promise<User | GraphQLError | null> {
    
    //Check if token is present.
    if (!ctx.token) return GQLError(ServerError.NOT_FOUND,"token");

    //Get values from token. Values in the token are provided by resolver and generated by generateToken() on ToktnMgmt.ts
    const decodedToken:User= await decodeToken(ctx.token) as User;

    //Check if the token is valid. Invalidity can be caused either due to malformed error or Expired Token 
    if (!decodedToken) return GQLError(ServerError.TOKEN_INVALID,"token");

    //Get Token saved in Redis
    let dbSavedToken = await ctx.redis.get(decodedToken.email);

    //Check if a token for the userId is present in redis
    if (!dbSavedToken) return GQLError(ServerError.TOKEN_INVALID,"token");

    //Removes the timestamp prefix
    dbSavedToken=formatTokenFromRedis(dbSavedToken);

    //Check if the token from redis and user provided are same. (Don't need to recheck validity of db token)
    if(dbSavedToken!==ctx.token) return GQLError(ServerError.TOKEN_INVALID, "token");


    // //Checks if the User already has a valid token
    // if(decodedToken.email===email) return;


    //Get User from database
    const user = ctx.prisma.user.findUnique({
        where: {
            id: decodedToken.id,
        },
    });

    if (!user && user===null) return GQLError(ServerError.NOT_FOUND, "user");

    return user;
}
